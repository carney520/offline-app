# 离线化方案及对比

* 基于现有的浏览器机制
* 基于传统 Hybrid 方案
* 基于开源的 Native 方案

## 基于现有的浏览器机制

HTML5 早期版本提供了`Application Cache`的缓存功能, 在`Service Worker`提出之后，`Application Cache`就从 Web 标准中移除了. 所以不在我们的讨论之列。

目前 PWA(Progressive Web App)是最被推荐的应用模型。它基于`Service Worker`为 Web 应用提供编程式缓存和离线能力，PWA 不是一项技术，而是一套 Web 应用模式，旨在让我们 Web 应用能够更接近原生应用的使用体验。 简单说它包含下列功能:

* 应用离线功能
* 支持安装到主屏幕, 就像原生应用一样有 Icon，启动页面
* 通知推送功能
* 后台同步功能
* 安全性更高(比如授权凭证管理，强制 HTTPS)
* 更全面的原生功能调用

`渐进式`的含义在于，这些特性是以渐进式的方式增加的，比传统应用更好的同时保证了降级兼容. 这里主要吸引我们的是它的离线能力。他的工作原理如下:

![运行方式](attachments/HowSWWork.png)

1.  在应用首次加载的时候, 我们会注册一个 SW 脚本。这是一个 JavaScript 程序，在独立的‘进程(Worker)’中运行，主要职责是管理缓存，推送等事务
2.  接着触发`install`事件. 我们可以在这里将应用的全部缓存，或者离线核心文件全部预缓存下来。
3.  安装成功后就触发了`activate`事件。在这里的主要工作是，当应用更新时，可以在这里删除缓存。
4.  激活成功后， SW 就会在一个独立的进程中运行，不依赖于具体的页面, 即使页面关闭的 SW 进程会一直运行(这说法不严谨, 浏览器会根据资源情况，休眠 SW 进程，但是对于我们的页面来说，可以认为是一直在运行的).
    激活成功后，SW 不能应用于当前页面，只有刷新或者新打开的页面才能被 SW 控制
5.  成功激活 SW 后续加载的页面都在 SW 控制范围内，在指定作用域请求的资源, 会触发`fetch`事件，被 SW 拦截。所以说 SW 就是一个代理，在这里可以先检查缓存，如果缓存存在的话，则将响应直接返回给页面；如果不存在则向服务器发起请求，接着再缓存起来。所有说，使用 SW 有两种缓存方案：
    1.  全站缓存，直接在`install`事件中，将所有静态资源预缓存下来。这种方式可以保证更好的离线效果
    2.  渐进式缓存，在`fetch`事件中，边请求变缓存。对于非核心文件可以使用这种方式

兼容性

1.  Chrome 44 工作宝 Android 端和 PC 端都是 Chrome 内核，可以完美支持
2.  桌面端 Safari 11.1
3.  IOS Safari 11.3 目前还是实验性功能，Webview 尚未开放（新时代 IE 浏览器）

优点

* 架构侵入性低，正如其名，可以渐进式增强。不影响现有的应用的开发和兼容。也就是说他只是我们应用的“附加功能”. 方便旧应用的迁入。
* 引入成本低，不用惊动三端。完全由前端控制
* 开发和调试方便

缺点

* 目前在 IOS 端(11.3)为实验性功能，引入 Webview 中还需要一些时间
* 我们还是要做首屏优化，因为只有在首次加载之后才能被缓存。但缓存是永久的, 由程序来控制更新

## 传统 Hybrid 方案

传统 Hybird 应用主要以`Cordova`为代表. 它的工作方式是将前端应用打包进原生应用中, 然后使用`file:///`协议页面进行加载；另外通过 Bridget 桥接方式(社区有丰富插件)给应用提供一定的原生访问能力. 其中，著名的 Ionic 框架就是为此而生的，他们的特点就是模仿原生的外观，以达到以假乱真的效果

下面描述一个工作方式提议：

![file](attachments/file.png)

1.  打开应用，客户端会先检查本地是否存在该应用的`归档`, 如果存在则  根据应用的`描述文件`使用`file:///`协议加载入口文件
2.  如果不存在，则向`应用管理系统`获取应用归档。
3.  在加载应用的同时，客户端会向应用管理系统检查是否有更新。如果有更新则下载最新的归档, 按照一定的策略，激活新的应用：
    1.  获取更新后强制更新应用, 这种策略使用**break change**的版本. 即服务端接口有重大变化，并不再向下兼容. 为了判断是**break change**还是**一般性**更新，我们可能会采用`语义化的版本号`, 或者特定的指令来通知客户端
    2.  在应用重新打开时激活, 适用于**一般性**更新
4.  页面加载后，前端页面通过`jssdk.getCode()`向客户端获取`Code`，并通过`Code`和`应用后端`交换`Token`。后续以这个`Token`和服务端交互
5.  鉴权完毕后，就可以开始业务交互了

> 上面只是一个简单的流程。工作宝应用一般会有多个入口：应用 Tab，会话 Tab，扩展消息，消息长按按钮。都需要客户端进行特殊处理.

> 由于应用由`使用范围`的概念, 而且不同企业,平台的应用是动态配置的.将前端归档打包进客户端会复杂化工作, 且不灵活.
>  打包过多应用, 会导致客户端过于臃肿

> 优化:
>
> 1.  预加载:  客户端可以选择在合适的时机将  前端归档文件下载下来,  从而避免在点击应用式花时间  加载

优点

* 前端实现简单( 支持 file 协议加载文件).
* 永久缓存, 静态资源加载不需要经过网络, 可以可靠地渲染出页面
* 支持所有客户端, 不存在兼容性问题

缺点

* 丢失了 Web 的更新灵活性。所以我们需要自定义更新协议，来弥补这个缺陷.
* 需要三端都实现应用归档的加载和更新协议, 成本较高
* 需要一个统一的 应用服务系统, 主要负责应用的上传, 更新和配置. 以及一些扩展功能, 比如数据统计.
* 需要一个可用的开发规范和工具, 以提升开发和调试效率
* 考虑多种入口的情况.
* 需要考虑工作宝向下兼容问题, 也就说为了兼容低版本工作宝  前端除了要提供离线归档文件,  还要提供在线版本

## 基于开源的 Native 方案

HTML5 页面的性能和用户体验和原生程序的还有一定的差距, 主要问题体现在刷新帧(FPS), 一旦刷新帧超过低于 60，用户就可以感知得到. 原生应用的优势在于用户组件交互和动画可以容易地到达 60FPS. 为了平衡 Web 的开发效率和运行性能，社区出现了许多'Native'方案. 这是一种新型的“混合应用”. 这类方案的典型代表是`React Native`:

![react native](attachments/react-native.png)

`React Native`基于`React`, 将组件渲染为原生的组件. 现代的前端框架都抽象了`渲染层`, 比如 Vue 和 React 都使用 Virtual DOM 作为一个抽象的渲染层，底层再由`渲染驱动`渲染成特定平台的格式。比如 React 除了可以渲染成浏览器的 DOM 对象，还可以渲染成原生组件。甚至可以渲染成 PDF，终端界面，Work 文档等等。

在 React Native 应用运行在 JavaScript 上下文, 通过原生应用提供的 Bridge 进行通讯。将对应的 React 组件渲染成对应平台的原生组件：

![bridget](attachments/bridget.png)

兼容性

支持 Web, IOS, Android 和 Windows. 其中主要官方支持 IOS, Android, 资源较多。而 Web 和 Windows 由社区支持

社区其他类似框架对比
|  指标 |React Native| Weex | NativeScript | Xamarin |Flutter|
|------|---|---|---|---|--|
|语言 | JavaScript |Javascript| Javascript|C#|Dart|
|框架 | React | 框架无关/默认为 Vue | Angular/Vue| - | - |
|API 稳定度| B | C| A | A | C |
|生态 | A | B | C | D | C|
|成熟度| A | C | B | C| C|
|支持|Facebook| Ali | | Microsoft | Google|
|成熟平台| IOS/Android/Web| IOS/Android/Web|IOS/Android| IOS/Android/Window| IOS/Android|

优点

* 进一步缩短了和原生开发的性能差距, 更好的手势支持, 支持高性能的动画
* 和 Web 开发一致的开发体验, 使用 Web 技术，对前端开发者无门槛
* 支持远程热更新
* 社区有丰富的插件和库, 文档成熟
* 大厂 APP 大量实践

缺点

* 提高了协作成本。原生开发和前端开发需要更多配合。不管是原生开发还是前端开发都需要一些交叉知识
* 对于一些自定义的原生组件/插件，需要原生开发配合开发
* 潜在成本。Native 方案还处于发展阶段，一些潜在成本是需要考虑的。一是更新迭代快，升级成本稍高(这里包括核心库，以及因为核心库升级而滞后的第三方库)；二是开发过程中的坑。
* 不是完美支持所有平台, 目前只推荐在 IOS 和 Android。还是需要对平台进行适配。暂时无法做到“编写一次，在所有平台运行”
* 潜在的风险。无法预料未来的 App Store 的审核变动. 不过有大厂打头阵，QQ，FaceBook，Ali 等大型 APP 都有用到 React Native
* 集成难度高于前面两种方案, 不向下兼容

## 方案对比

以下`Native Hybrid`简称`NH`, `Webview Hybrid` 简称 WH.

| 首次加载 | 性能   | 开发效率 | 代码复用度 | 引入成本 | 潜在成本 | 热更新支持 |  平台兼容性 |  向下兼容性                    |
| -------- | ------ | -------- | ---------- | -------- | -------- | ---------- | ----------- | ------------------------------ |
| NH       | NH     | WH/PWA   | WH/PWA     | NH       | NH       | PWA        | PWA/WH      | PWA(无成本)                    |
| WH       | WH/PWA | NH       | NH         | WH       | WH/PWA   | WH         | NH          | WH(旧版本需要提供网页加载方式) |
| PWA      |        |          |            | PWA      |          | NH         |             | NH(不兼容)                     |
