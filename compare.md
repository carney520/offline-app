# 离线化方案及对比

> 从纯 Web 到纯 Native，之间有许多可能的点
> -- 贺师俊

![Web到Native](attachments/webtonative.png)

图片截取自 [`黄玄的演讲slice`](https://huangxuan.me/sw-101-gdgdf)

* 基于现有的浏览器机制
* 基于传统 Hybrid 方案
* 基于开源的 Native 方案

## 基于现有的浏览器机制

### 基于 HTTP 的缓存机制

HTTP 的缓存机制主要是在服务器端通过 HTTP 报头的方式进行控制。其工作流程如下:

![http cache](attachments/httpcache.png)

* `强缓存`：强缓存使用`Expires`和`Cache-Control`来设置. 这两个报头都用于设置一个绝对的过期时间。设置这两个报头的静态资源被加载时，浏览器会检查是否过期，如果未过期，浏览器会直接加载资源，不会向服务器发起请求. 这就是所谓的强缓存
* 协商缓存：协商缓存主要使用以下报头来控制.
  * `Last-Modified/If-Modified-Since`: 使用资源的更新时间来判断是否需要重新请求
  * `Etag/If-None-Match`: 使用资源的`标签`匹配来判断是否要重新请求。`标签`一般是资源的唯一标志，比如内容的 Hash 码

> 注意: html 入口文件不能加`强缓存`

局限性:

* 缓存不可靠性:
  * 用户行为对缓存的影响(图片来自: [http 协商缓存 VS 强缓存](http://www.cnblogs.com/wonyun/p/5524617.html))
    ![用户行为对缓存的影响](attachments/httpcache-behav.png)
    即用户刷新会导致缓存无效。
  * 缓存由浏览器控制, 无法控制其缓存清理逻辑. 比如在系统资源紧张的情况下, 缓存可以被清理掉
* 对于强缓存的资源，如果未过期，除非用户强制刷新，会一直使用旧的版本。可能会导致程序错误(比如缓存了入口文件)。可以使用 添加查询字符串的方式, 让浏览器放弃缓存
* 无法使用程序干预和控制缓存
* 不支持离线

### 浏览器缓存

HTML5 早期版本提供了`Application Cache`的缓存功能, 在`Service Worker`提出之后，`Application Cache`就从 `Web 标准`中移除了, 在未来浏览器会停止支持(部分浏览器目前会警告)。不过我们可以了解一下他的缓存原理:

![Application Cache](attachments/appcache.png)

Appcahce 使用`manifest`文件来声明 应该缓存哪些资源, 典型 格式为:

```bash
# 版本号, 修改版本和触发更新
# v1 - 2011-08-13
# 声明要缓存的静态资源
CACHE MANIFEST
http://www.example.com/index.html
http://www.example.com/header.png
http://www.example.com/blah/blah

# 声明绕过缓存, 或者资源不存在时是否可以通过网络请求
# 可以使用通配符, * 表示除了CACHE声明的, 其他使用网络
NETWORK:
network.html

# 回退: 声明当资源无法访问时, 浏览器使用该资源
FALLBACK:
/ fallback.html
```

优点

* 兼容性好, 但是是废弃的 Web 标准, 未来可能成为历史包袱
* manifest 缓存和浏览器 HTTP 缓存是独立的, 不受其影响. 可以永久缓存

缺点

* 使用声明式设计声明缓存文件. 不可编程, 比如你无法条件性地缓存. 如果同时支持 PC 端移动端，也会将所有不需要的资源缓存下载
* 不同浏览器实现有些 bug
* API 存在较多设计缺陷. 比如
  * 即使 manifest 文件丢失, 但 html 节点中的 manifest 属性没有删除, 缓存依然有效
  * 全量 缓存, 一旦 manifest 更新, 所有文件将被重新缓存一遍
  * 标记了 manifest 的 html 本身也被缓存，而且无法清除. 除非 manifest 自身变动了(比如改一个版本号)
  * 未缓存的资源在已缓存的页面不会被加载, 即使是在线
  * 如果更新的资源中有一个资源更新失败了，将导致全部更新失败，将用回上一版本的缓存
  * 重定向被处理为访问失败
  * fallback 机制，无法区分网络错误还是状态码
  * 没有缓存清理机制
  * 一旦缓存出问题, 将极大影响用户体验

> 具体的缺陷可以查看这些文章:
>
> * [Application Cache is a Douchebag](https://alistapart.com/article/application-cache-is-a-douchebag)
> * [....](https://huangxuan.me/sw-101-gdgdf/#/12)

### PWA

目前 PWA(Progressive Web App)是最被推荐的应用模型。它基于`Service Worker`为 Web 应用提供编程式缓存和离线能力，PWA 不是一项技术，而是一套 Web 应用模式，旨在让我们 Web 应用能够更接近原生应用的使用体验。 简单说它包含下列功能:

* 应用离线功能
* 支持安装到主屏幕, 就像原生应用一样有 Icon，启动页面
* 通知推送功能
* 后台同步功能
* 安全性更高(比如授权凭证管理，强制 HTTPS)
* 更全面的原生功能调用

`渐进式`的含义在于，这些特性是以渐进式的方式增加的，比传统应用更好的同时保证了降级兼容. 这里主要吸引我们的是它的离线能力。他的工作原理如下:

![运行方式](attachments/HowSWWork.png)

1.  在应用首次加载的时候, 我们会注册一个 SW 脚本。这是一个 JavaScript 程序，在独立的‘进程(Worker)’中运行，主要职责是管理缓存，推送等事务
2.  接着触发`install`事件. 我们可以在这里将应用的全部缓存，或者离线核心文件全部预缓存下来。
3.  安装成功后就触发了`activate`事件。在这里的主要工作是，当应用更新时，可以在这里删除缓存。
4.  激活成功后， SW 就会在一个独立的进程中运行，不依赖于具体的页面, 即使页面关闭的 SW 进程会一直运行(这说法不严谨, 浏览器会根据资源情况，休眠 SW 进程，但是对于我们的页面来说，可以认为是一直在运行的).
    激活成功后，SW 不能应用于当前页面，只有刷新或者新打开的页面才能被 SW 控制
5.  成功激活 SW 后续加载的页面都在 SW 控制范围内，在指定作用域请求的资源, 会触发`fetch`事件，被 SW 拦截。所以说 SW 就是一个代理，在这里可以先检查缓存，如果缓存存在的话，则将响应直接返回给页面；如果不存在则向服务器发起请求，接着再缓存起来。所有说，使用 SW 有两种缓存方案：
    1.  全站缓存，直接在`install`事件中，将所有静态资源预缓存下来。这种方式可以保证更好的离线效果
    2.  渐进式缓存，在`fetch`事件中，边请求变缓存。对于非核心文件可以使用这种方式

兼容性

1.  Chrome 44 工作宝 Android 端和 PC 端都是 Chrome 内核，可以完美支持
2.  桌面端 Safari 11.1
3.  IOS Safari 11.3 目前还是实验性功能，Webview 尚未开放（新时代 IE 浏览器）

优点

* 架构侵入性低，正如其名，可以渐进式增强。不影响现有的应用的开发和兼容。也就是说他只是我们应用的“附加功能”. 方便旧应用的迁入。
* 引入成本低，不用惊动三端。完全由前端控制
* 开发和调试方便

缺点

* 目前在 IOS 端(11.3)为实验性功能，引入 Webview 中还需要一些时间
* 第一次打开没有预加载机制, 我们还是要做首屏优化，因为只有在首次加载之后才能被缓存。但缓存是永久的, 由程序来控制更新

## 传统 Hybrid 方案

传统 Hybird 应用主要以`Cordova`为代表. 它的工作方式是将前端应用打包进原生应用中, 然后使用`file:///`协议页面进行加载；另外通过 Bridget 桥接方式(社区有丰富插件)给应用提供一定的原生访问能力. 其中，著名的 Ionic 框架就是为此而生的，他们的特点就是模仿原生的外观，以达到以假乱真的效果

下面描述一个工作方式提议：

![file](attachments/file.png)

1.  打开应用，客户端会先检查本地是否存在该应用的`归档`, 如果存在则 根据应用的`描述文件`使用`file:///`协议加载入口文件
2.  如果不存在，则向`应用管理系统`获取应用归档。
3.  在加载应用的同时，客户端会向应用管理系统检查是否有更新。如果有更新则下载最新的归档, 按照一定的策略，激活新的应用：
    1.  获取更新后强制更新应用, 这种策略使用**break change**的版本. 即服务端接口有重大变化，并不再向下兼容. 为了判断是**break change**还是**一般性**更新，我们可能会采用`语义化的版本号`, 或者特定的指令来通知客户端
    2.  在应用重新打开时激活, 适用于**一般性**更新
4.  页面加载后，前端页面通过`jssdk.getCode()`向客户端获取`Code`，并通过`Code`和`应用后端`交换`Token`。后续以这个`Token`和服务端交互
5.  鉴权完毕后，就可以开始业务交互了

> 上面只是一个简单的流程。工作宝应用一般会有多个入口：应用 Tab，会话 Tab，扩展消息，消息长按按钮。都需要客户端进行特殊处理.

> 由于应用由`使用范围`的概念, 而且不同企业,平台的应用是动态配置的.将前端归档打包进客户端会复杂化工作, 且不灵活.
> 打包过多应用, 会导致客户端过于臃肿

> 优化:
>
> 1.  预加载: 客户端可以选择在合适的时机将前端归档文件下载下来, 从而避免在点击应用式花时间加载
> 2.  增加更新：由于前端应用使用自动的打包机制，为了避免缓存，文件一般命名为`name-[hash].ext`, 每次打包，如果文件发生变动都会生成一个新的文件

优点

* 前端实现简单( 支持 file 协议加载文件).
* 永久缓存, 静态资源加载不需要经过网络, 可以可靠地渲染出页面
* 支持所有客户端, 不存在兼容性问题
* 自定义实现离线化, 相比 APP Cache 机制 有更高的自由度

缺点

* 丢失了 Web 的更新灵活性。所以我们需要自定义更新协议，来弥补这个缺陷.
* 需要三端都实现应用归档的加载和更新协议, 成本较高
* 需要一个统一的 应用服务系统, 主要负责应用的上传, 更新和配置. 以及一些扩展功能, 比如数据统计.
* 需要一个可用的开发规范和工具, 以提升开发和调试效率
* 考虑多种入口的情况.
* 需要考虑工作宝向下兼容问题, 也就说为了兼容低版本工作宝 前端除了要提供离线归档文件, 还要提供在线版本

### 更多方案

为了实现更好的向下兼容, 也有采取Webview拦截的方案. 具体见[转转hybrid app web静态资源离线系统实践](http://zzfe.org/#/detail/5a5376c970aaa1172d26442b)

## 基于开源的 Native 方案

HTML5 页面的性能和用户体验和原生程序的还有一定的差距, 主要问题体现在刷新帧(FPS), 一旦刷新帧超过低于 60，用户就可以感知得到. 原生应用的优势在于用户组件交互和动画可以容易地到达 60FPS. 为了平衡 Web 的开发效率和运行性能，社区出现了许多'Native'方案. 这是一种新型的“混合应用”. 这类方案的典型代表是`React Native`:

![react native](attachments/react-native.png)

`React Native`基于`React`, 将组件渲染为原生的组件. 现代的前端框架都抽象了`渲染层`, 比如 Vue 和 React 都使用 Virtual DOM 作为一个抽象的渲染层，底层再由`渲染驱动`渲染成特定平台的格式。比如 React 除了可以渲染成浏览器的 DOM 对象，还可以渲染成原生组件。甚至可以渲染成 PDF，终端界面，Work 文档等等。

在 React Native 应用运行在 JavaScript 上下文, 通过原生应用提供的 Bridge 进行通讯。将对应的 React 组件渲染成对应平台的原生组件：

![bridget](attachments/bridget.png)

兼容性

支持 Web, IOS, Android 和 Windows. 其中主要官方支持 IOS, Android, 资源较多。而 Web 和 Windows 由社区支持

社区其他类似框架对比

| 指标 |React Native| Weex | NativeScript | Xamarin |Flutter|
|------|---|---|---|---|--|
|语言 | JavaScript |Javascript| Javascript|C#|Dart|
|框架 | React | 框架无关/默认为 Vue | Angular/Vue| - | - |
|API 稳定度| B | C| A | A | C |
|生态 | A | B | C | D | C|
|成熟度| A | C | B | C| C|
|支持|Facebook| Ali | | Microsoft | Google|
|成熟平台| IOS/Android/Web| IOS/Android/Web|IOS/Android| IOS/Android/Window| IOS/Android|

优点

* 进一步缩短了和原生开发的性能差距, 更好的手势支持, 支持高性能的动画
* 和 Web 开发一致的开发体验, 使用 Web 技术，对前端开发者无门槛
* 支持远程热更新
* 社区有丰富的插件和库, 文档成熟
* 大厂 APP 大量实践

缺点

* 提高了协作成本。原生开发和前端开发需要更多配合。不管是原生开发还是前端开发都需要一些交叉知识, 有一定学习成本
* 对于一些自定义的原生组件/插件，需要原生开发配合开发
* 潜在成本。Native 方案还处于发展阶段，一些潜在成本是需要考虑的。一是更新迭代快，升级成本稍高(这里包括核心库，以及因为核心库升级而滞后的第三方库)；二是开发过程中的坑。
* 不是完美支持所有平台, 目前只推荐在 IOS 和 Android。还是需要对平台进行适配。暂时无法做到“编写一次，在所有平台运行”
* 潜在的风险。无法预料未来的 App Store 的审核变动. 不过有大厂打头阵，QQ，FaceBook，Ali 等大型 APP 都有用到 React Native
* 集成难度高于前面两种方案, 不向下兼容

## 方案对比

以下`Native Hybrid`简称`NH`, `Webview Hybrid` 简称 WH.

| 首次加载 | 性能   | 开发效率 | 代码复用度 | 引入成本 | 潜在成本 | 热更新支持 | 平台兼容性 | 向下兼容性                     |
| -------- | ------ | -------- | ---------- | -------- | -------- | ---------- | ---------- | ------------------------------ |
| NH       | NH     | WH/PWA   | WH/PWA     | NH       | NH       | PWA        | WH         | PWA(无成本)                    |
| WH       | WH/PWA | NH       | NH         | WH       | WH/PWA   | WH         | PWA        | WH(旧版本需要提供网页加载方式) |
| PWA      |        |          |            | PWA      |          | NH         | NH         | NH(不兼容)                     |

## 参考文献

* [下一代 Web 应用模型 —— Progressive Web App](https://huangxuan.me/2017/02/09/nextgen-web-pwa/)
* [转转hybrid app web静态资源离线系统实践](http://zzfe.org/#/detail/5a5376c970aaa1172d26442b)
* [手机QQ Hybrid APP优化新思路](http://blog.xiayf.cn/assets/uploads/files/AK-hybrid-app.pdf)
* [浏览器的缓存机制](http://coderlt.coding.me/2016/11/21/web-cache/)
* [http 协商缓存 VS 强缓存](http://www.cnblogs.com/wonyun/p/5524617.html)
* [移动 H5 首屏秒开优化方案探讨](https://blog.cnbang.net/tech/3477/)
* [MDN HTTP 缓存](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching_FAQ)
* [缓存策略](http://imweb.io/topic/55c6f9bac222e3af6ce235b9)
* [为什么 app cache 没有得到大规模应用？它有哪些硬伤吗？](https://www.zhihu.com/question/29876535)
* [聊一聊 H5 应用缓存-Manifest](http://louiszhai.github.io/2016/11/25/manifest/)
